"use strict";
const command_1 = require("@oclif/command");
const chalk = require("chalk");
const command_exists_1 = require("command-exists");
const emoji = require("node-emoji");
const opn = require("open");
const path = require("path");
const tempDirectory = require("temp-dir");
const urlParse = require("url-parse");
const util = require("util");
const uuid_1 = require("uuid");
// tslint:disable-next-line: no-var-requires
const pjson = require("../package.json");
// tslint:disable-next-line: no-var-requires
const exec = util.promisify(require("child_process").exec);
class ReactInstant extends command_1.Command {
    constructor() {
        super(...arguments);
        this.verbose = false;
        this.prefersYarn = false;
        this.dir = "";
        this.platform = process.platform;
        this.missingDeps = []; // Allows using fallback to npx.
    }
    /**
     * Prefered package manager. (yarn or npm)
     */
    get getPM() {
        return this.prefersYarn ? "yarn" : "npm";
    }
    /**
     * Here it all begins...
     */
    async run() {
        var _a;
        this.log(`react-instant v${pjson.version}\n`);
        const { args, flags: flgs } = this.parse(ReactInstant);
        this.verbose = flgs.verbose;
        this.dir = path.resolve(flgs.save || `${tempDirectory}/react-instant-${uuid_1.v1()}`);
        this.verboseLog(`Path was set to ${this.dir}`);
        const gitUrl = this.parseUrl(args.git_url);
        // TODO: Refactor to own "showWarnings" function.
        // Warn about active --omitServe flag.
        !!flgs.omitServe && !flgs.save &&
            this.log(`${emoji.get("warning")} ${chalk.yellow("Running command with --omitServe flag. It has no effect unless you save the project by using --save flag.")}`);
        // Warn about active --excludeTest flag.
        !!flgs.excludeTest &&
            this.log(`${emoji.get("warning")} ${chalk.yellow('Running command with --excludeTest flag. Testing step will be skipped.')}`);
        this.log(`\n`); // Just a touch of elegancy. :D
        // Resolve the env path.
        flgs.envPath = flgs.envPath ? path.resolve(flgs.envPath || "") : undefined;
        process.on("SIGINT", async () => {
            if (flgs.forceClean)
                await this.cleanRepo();
            process.exit();
        });
        await this.checkDependencies();
        await this.cloneRepo(gitUrl, flgs.branch);
        await this.copyFiles(flgs.envPath);
        await this.installDeps();
        if (!flgs.excludeTest)
            await this.testRepo();
        await this.buildRepo((_a = flgs.buildScript, (_a !== null && _a !== void 0 ? _a : "build")));
        if (flgs.omitServe)
            this.exit(0);
        await this.serveRepo(flgs.port || 5000);
    }
    /**
     * Checks if required packages are installed.
     */
    async checkDependencies() {
        // Check for yarn
        if (command_exists_1.sync("yarn")) {
            this.prefersYarn = true;
            this.verboseLog("Default package manager set to yarn.");
        }
        // Check for git
        if (!command_exists_1.sync("git")) {
            throw new Error("'git' is not installed.");
        }
        if (!command_exists_1.sync("serve")) {
            this.missingDeps.push("serve");
        }
    }
    /**
     * Clones git repository.
     * @param url URL to repository.
     */
    async cloneRepo(url, branch) {
        this.log(`${emoji.get('floppy_disk')} Cloning ${chalk.underline(url)}...`);
        this.verboseLog(`Cloning ${url} to ${this.dir}...`);
        this.verboseLog(await exec(`git clone ${url} ${this.dir}`));
        this.verboseLog(await exec(`cd ${this.dir} && git fetch`));
        if (branch) {
            this.log(`${emoji.get("twisted_rightwards_arrows")} Switching branch to ${chalk.underline(branch)}`);
            this.verboseLog(await exec(`cd ${this.dir} && git checkout ${branch}`));
        }
    }
    /**
     * Copies sideloaded files.
     * @param envPath Path to .env file.
     * TODO: Refactor.
     */
    async copyFiles(envPath) {
        if (envPath === undefined /*|| ...*/) {
            return;
        }
        this.log(`${emoji.get("clipboard")} Copying additional files...`);
        if (envPath) {
            this.verboseLog("envPath = " + envPath);
            if (this.platform === "win32") {
                const cmdExec = await exec(`xcopy "${envPath}" "${this.dir}" /h`);
                this.verboseLog(cmdExec);
                try {
                    const cmdTestExec = await exec(`type "${path.resolve(this.dir + "\\.env")}"`);
                    this.verboseLog(cmdTestExec);
                }
                catch (err) {
                    this.verboseLog(err.message);
                    throw new Error("There was an error while copying .env file.");
                }
                // Throw an error if no file is copied.
                if (cmdExec.stdout.includes("0 File(s) copied"))
                    throw new Error("Unable to copy .env file. Please make sure the path is correct.");
            }
            else {
                const cmdExec = await exec(`cp "${envPath}" "${this.dir}/.env"`);
                this.verboseLog(cmdExec);
                try {
                    const cmdTestExec = await exec(`test -f "${path.resolve(this.dir + "/.env")}" && echo "ok."`);
                    this.verboseLog(cmdTestExec);
                    if ((!cmdTestExec.stdout.includes("ok.")))
                        throw new Error("Unable to copy .env file. Please make sure the path is correct.");
                }
                catch (err) {
                    this.verboseLog(err.message);
                    throw new Error("There was an error while copying .env file.");
                }
            }
            this.verboseLog(`Copied ${chalk.underline(".env")} file.`);
        }
    }
    /**
     * Installs project's dependencies.
     */
    async installDeps() {
        this.log(`${emoji.get("package")} Installing dependencies...`);
        const waitTimeout = setTimeout(() => {
            this.log(emoji.get("construction") + " Still working... Please be patient.");
        }, 1000 * 60 * 60 * 2);
        this.verboseLog(await exec(`cd ${this.dir} && ${this.constructPMCommand({ npm: `install` })}`));
        clearTimeout(waitTimeout);
    }
    /**
     * Builds project.
     * @param buildScript Script name for building project. (Defaults to "build")
     */
    async buildRepo(buildScript) {
        this.log(`${emoji.get("building_construction")} Building project...`);
        this.verboseLog(await exec(`cd ${this.dir} && ${this.constructPMCommand({ yarn: buildScript, npm: `run-script ${buildScript}` })}`));
    }
    /**
     * Tests project.
     */
    async testRepo() {
        this.log(`${emoji.get("white_check_mark")} Testing project...`);
        try {
            this.verboseLog(await exec(`cd ${this.dir} && ${this.constructPMCommand({ yarn: "test --watchAll=false", npm: `run-script test --watchAll=false` })}`));
        }
        catch (err) {
            this.verboseLog(err);
            this.log(`${emoji.get("boom")} A test failed. You can try running the command with a "--excludeTest" flag.`);
            throw new Error('A test failed. You can try running the command with a "--excludeTest" flag.');
        }
    }
    /**
     * Serves project.
     * @param port Served port.
     */
    async serveRepo(port) {
        this.log(emoji.get("rocket") + " Serving project on port " + chalk.underline(port) + "...\n");
        // tslint:disable-next-line: no-http-string
        await opn(`http://localhost:${port}/`, { url: true });
        const npxPrefix = this.missingDeps.includes("serve") ? "npx " : "";
        const cmd = `${npxPrefix} serve -s build -l ${port}`;
        try {
            this.log(`Now you can preview this project under ${chalk.underline(`http://localhost:${port}/`)}`);
            this.verboseLog(await exec(`cd ${this.dir} && ${cmd}`));
        }
        catch (err) {
            this.verboseLog(err);
            this.log(`${emoji.get("boom")} ${chalk.red("An error occurred while serving the project. Make sure the 'serve' is installed and the build directory is named 'build'.")}`);
            process.exit(1);
        }
    }
    async cleanRepo() {
        this.log(emoji.get("wastebasket") + " Cleaning up...");
        try {
            if (this.platform === "win32") {
                this.verboseLog(await exec(`rmdir "${this.dir}" /s /q`));
            }
            else {
                this.verboseLog(await exec(`rm -rf ${this.dir}`));
            }
        }
        catch (err) {
            this.verboseLog(err.message);
            this.log(`${emoji.get("boom")} ${chalk.red(`An error occurred while cleaning repo. Please try doing it manually by deleting the directory (${chalk.underline(this.dir)})`)}`);
        }
    }
    /**
     * Prints verbose log.
     * @param args Message.
     */
    verboseLog(...args) {
        if (!this.verbose) {
            return;
        }
        this.log(`${emoji.get("point_right")} `, ...args);
    }
    /**
     * Parses git url.
     * @param url Url to repository. eg. https://github.com/user/repo.git or user/repo
     */
    parseUrl(url) {
        if (!url) {
            throw new Error(emoji.get("no_entry") + " No git url provided");
        }
        this.verboseLog(url);
        // tslint:disable-next-line: strict-type-predicates triple-equals
        if (urlParse(url, true).origin != "null") {
            return url;
        }
        if (url.split("/").length === 2) {
            return `https://github.com/${url}`;
        }
        throw new Error(emoji.get("no_entry") + " Provided invalid git url.");
    }
    /**
     * Constructs an command for prefered package manager.
     * @param args String args for both yarn and npm or an object with separated args for each package manager.
     */
    constructPMCommand(args) {
        var _a, _b;
        const pm = this.getPM;
        if (typeof args === "string")
            return `${pm} ${args}`;
        else if (pm === "yarn") {
            return `yarn ${_a = args.yarn, (_a !== null && _a !== void 0 ? _a : "")}`;
        }
        else {
            return `npm ${_b = args.npm, (_b !== null && _b !== void 0 ? _b : "")}`;
        }
    }
}
ReactInstant.description = "Launches preview of a remote React project.";
ReactInstant.flags = {
    branch: command_1.flags.string({ char: "b", description: "Specify git branch." }),
    buildScript: command_1.flags.string({ description: "Script name executed on build." }),
    envPath: command_1.flags.string({ description: "Path to .env file." }),
    excludeTest: command_1.flags.boolean({ description: "Skip the testing step.", default: false }),
    forceClean: command_1.flags.boolean({ description: "Forces clean-up at the very end." }),
    omitServe: command_1.flags.boolean({ description: "Omits the serving step.", default: false }),
    port: command_1.flags.integer({ char: "p", description: "Custom port." }),
    save: command_1.flags.string({ char: "s", description: "Provide an url to save the project permanenty." }),
    verbose: command_1.flags.boolean(),
    version: command_1.flags.version({ char: "v" }),
};
ReactInstant.args = [{ name: "git_url" }];
module.exports = ReactInstant;
