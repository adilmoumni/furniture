import{createSSRApp as e}from"vue";import"./vue-compat/index-3.js";import{warn as t}from"./warn.js";import n from"instantsearch.js/es";import r from"algoliasearch-helper";var i=r.SearchResults,s=r.SearchParameters;function a(t,n){void 0===n&&(n={});var r=n.mixins;void 0===r&&(r=[]);var i,s={serverPrefetch:void 0,fetch:void 0,_base:void 0,name:"ais-ssr-root-component"},a=Object.assign({},t.$options,s);return a.mixins=a.mixins.concat(r),i=e(a),t.$router&&i.use(t.$router),t.$store&&i.use(t.$store),i.$slots=t.$slots,i.$root=t.$root,i}function o(e,a,o,c){var u,d=r(a,o),f=n(e);return f.findResultsState=function(e){var t,n,r=e.component,i=e.renderToString;if(!i)throw new Error("findResultsState requires `renderToString: (component) => Promise<string>` in the first argument.");return Promise.resolve().then(function(){t=c(r,{mixins:[{created:function(){n=this,this.instantsearch.helper=d,this.instantsearch.mainHelper=d,this.instantsearch.mainIndex.init({instantSearchInstance:this.instantsearch,parent:null,uiState:this.instantsearch._initialUiState})}}]})}).then(function(){return i(t)}).then(function(){return function(e){return new Promise(function(t,n){e.searchOnlyWithDerivedHelpers(),e.derivedHelpers[0].on("result",function(){t()}),e.derivedHelpers.forEach(function(e){return e.on("error",function(e){n(e)})})})}(d)}).then(function(){var e={};return function e(t,n){return n(t),t.getWidgets().forEach(function(t){"ais.index"===t.$$type&&(n(t),e(t,n))})}(n.instantsearch.mainIndex,function(t){e[t.getIndexId()]=t.getResults()}),f.hydrate(e),u=Object.keys(e).map(function(t){var n=e[t],r=n._state,i=n._rawResults;return[t,{_state:Object.keys(r).reduce(function(e,t){return e[t]=r[t],e},{}),_rawResults:i}]}).reduce(function(e,t){var n=t[0],r=t[1];return e[n]=r,e},{__identifier:"stringified"}),f.getState()})},f.getState=function(){if(!u)throw new Error("You need to wait for findResultsState to finish");return u},f.__forceRender=function(e,t){var n=t.getHelper(),r=f.__initialSearchResults[t.getIndexId()];if(r){var i=r._state;n.state=i,e.render({helper:n,results:r,scopedResults:t.getScopedResults().map(function(e){return Object.assign(e,{results:f.__initialSearchResults[e.indexId]})}),parent:t,state:i,templatesConfig:{},createURL:t.createURL,instantSearchInstance:f,searchMetadata:{isSearchStalled:!1}})}},f.hydrate=function(e){if(e){var n="stringified"===e.__identifier?Object.keys(e).reduce(function(t,n){return"__identifier"===n?t:(t[n]=new i(new s(e[n]._state),e[n]._rawResults),t)},{}):e;f.__initialSearchResults=n,f.helper=d,f.mainHelper=d,f.mainIndex.init({instantSearchInstance:f,parent:null,uiState:f._initialUiState})}else t("The result of `findResultsState()` needs to be passed to `hydrate()`.")},f}function c(e){void 0===e&&(e={});var t=e.searchClient,n=e.indexName,r=e.$cloneComponent;if(void 0===r&&(r=a),!t||!n)throw new Error("createServerRootMixin requires `searchClient` and `indexName` in the first argument");var i=o(e,t,n,r);return{provide:function(){return{$_ais_ssrInstantSearchInstance:this.instantsearch}},data:function(){return{instantsearch:i}}}}export{c as createServerRootMixin};
//# sourceMappingURL=createServerRootMixin.js.map
