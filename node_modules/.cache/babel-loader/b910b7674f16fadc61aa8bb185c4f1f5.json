{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { checkRendering, aroundLatLngToPosition, insideBoundingBoxToBoundingBox, createDocumentationMessageGenerator, createSendEventForHits, noop } from '../../lib/utils';\nvar withUsage = createDocumentationMessageGenerator({\n  name: 'geo-search',\n  connector: true\n}); // in this connector, we assume insideBoundingBox is only a string,\n// even though in the helper it's defined as number[][] alone.\n// This can be done, since the connector assumes \"control\" of the parameter\n\nfunction getBoundingBoxAsString(state) {\n  return state.insideBoundingBox || '';\n}\n\nfunction setBoundingBoxAsString(state, value) {\n  return state.setQueryParameter('insideBoundingBox', value);\n}\n\nvar $$type = 'ais.geoSearch';\n/**\n * The **GeoSearch** connector provides the logic to build a widget that will display the results on a map. It also provides a way to search for results based on their position. The connector provides functions to manage the search experience (search on map interaction or control the interaction for example).\n *\n * @requirements\n *\n * Note that the GeoSearch connector uses the [geosearch](https://www.algolia.com/doc/guides/searching/geo-search) capabilities of Algolia. Your hits **must** have a `_geoloc` attribute in order to be passed to the rendering function.\n *\n * Currently, the feature is not compatible with multiple values in the _geoloc attribute.\n */\n\nvar connectGeoSearch = function connectGeoSearch(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  checkRendering(renderFn, withUsage());\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        _ref$enableRefineOnMa = _ref.enableRefineOnMapMove,\n        enableRefineOnMapMove = _ref$enableRefineOnMa === void 0 ? true : _ref$enableRefineOnMa,\n        _ref$transformItems = _ref.transformItems,\n        transformItems = _ref$transformItems === void 0 ? function (items) {\n      return items;\n    } : _ref$transformItems;\n\n    var widgetState = {\n      isRefineOnMapMove: enableRefineOnMapMove,\n      // @MAJOR hasMapMoveSinceLastRefine -> hasMapMovedSinceLastRefine\n      hasMapMoveSinceLastRefine: false,\n      lastRefinePosition: '',\n      lastRefineBoundingBox: '',\n      internalToggleRefineOnMapMove: noop,\n      internalSetMapMoveSinceLastRefine: noop\n    };\n\n    var getPositionFromState = function getPositionFromState(state) {\n      return state.aroundLatLng ? aroundLatLngToPosition(state.aroundLatLng) : undefined;\n    };\n\n    var getCurrentRefinementFromState = function getCurrentRefinementFromState(state) {\n      return state.insideBoundingBox && insideBoundingBoxToBoundingBox(state.insideBoundingBox);\n    };\n\n    var refine = function refine(helper) {\n      return function (_ref2) {\n        var ne = _ref2.northEast,\n            sw = _ref2.southWest;\n        var boundingBox = [ne.lat, ne.lng, sw.lat, sw.lng].join();\n        helper.setState(setBoundingBoxAsString(helper.state, boundingBox).resetPage()).search();\n        widgetState.hasMapMoveSinceLastRefine = false;\n        widgetState.lastRefineBoundingBox = boundingBox;\n      };\n    };\n\n    var clearMapRefinement = function clearMapRefinement(helper) {\n      return function () {\n        helper.setQueryParameter('insideBoundingBox', undefined).search();\n      };\n    };\n\n    var isRefinedWithMap = function isRefinedWithMap(state) {\n      return function () {\n        return Boolean(state.insideBoundingBox);\n      };\n    };\n\n    var toggleRefineOnMapMove = function toggleRefineOnMapMove() {\n      return widgetState.internalToggleRefineOnMapMove();\n    };\n\n    var createInternalToggleRefinementOnMapMove = function createInternalToggleRefinementOnMapMove(renderOptions, render) {\n      return function () {\n        widgetState.isRefineOnMapMove = !widgetState.isRefineOnMapMove;\n        render(renderOptions);\n      };\n    };\n\n    var isRefineOnMapMove = function isRefineOnMapMove() {\n      return widgetState.isRefineOnMapMove;\n    };\n\n    var setMapMoveSinceLastRefine = function setMapMoveSinceLastRefine() {\n      return widgetState.internalSetMapMoveSinceLastRefine();\n    };\n\n    var createInternalSetMapMoveSinceLastRefine = function createInternalSetMapMoveSinceLastRefine(renderOptions, render) {\n      return function () {\n        var shouldTriggerRender = widgetState.hasMapMoveSinceLastRefine !== true;\n        widgetState.hasMapMoveSinceLastRefine = true;\n\n        if (shouldTriggerRender) {\n          render(renderOptions);\n        }\n      };\n    };\n\n    var hasMapMoveSinceLastRefine = function hasMapMoveSinceLastRefine() {\n      return widgetState.hasMapMoveSinceLastRefine;\n    };\n\n    var sendEvent;\n    return {\n      $$type: $$type,\n      init: function init(initArgs) {\n        var instantSearchInstance = initArgs.instantSearchInstance;\n        var isFirstRendering = true;\n        widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementOnMapMove(initArgs, noop);\n        widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(initArgs, noop);\n        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(initArgs)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), isFirstRendering);\n      },\n      render: function render(renderArgs) {\n        var helper = renderArgs.helper,\n            instantSearchInstance = renderArgs.instantSearchInstance;\n        var isFirstRendering = false; // We don't use the state provided by the render function because we need\n        // to be sure that the state is the latest one for the following condition\n\n        var state = helper.state;\n        var positionChangedSinceLastRefine = Boolean(state.aroundLatLng) && Boolean(widgetState.lastRefinePosition) && state.aroundLatLng !== widgetState.lastRefinePosition;\n        var boundingBoxChangedSinceLastRefine = !state.insideBoundingBox && Boolean(widgetState.lastRefineBoundingBox) && state.insideBoundingBox !== widgetState.lastRefineBoundingBox;\n\n        if (positionChangedSinceLastRefine || boundingBoxChangedSinceLastRefine) {\n          widgetState.hasMapMoveSinceLastRefine = false;\n        }\n\n        widgetState.lastRefinePosition = state.aroundLatLng || '';\n        widgetState.lastRefineBoundingBox = getBoundingBoxAsString(state);\n        widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementOnMapMove(renderArgs, this.render.bind(this));\n        widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(renderArgs, this.render.bind(this));\n        var widgetRenderState = this.getWidgetRenderState(renderArgs);\n        sendEvent('view', widgetRenderState.items);\n        renderFn(_objectSpread(_objectSpread({}, widgetRenderState), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), isFirstRendering);\n      },\n      getWidgetRenderState: function getWidgetRenderState(renderOptions) {\n        var helper = renderOptions.helper,\n            results = renderOptions.results,\n            instantSearchInstance = renderOptions.instantSearchInstance;\n        var state = helper.state;\n        var items = results ? transformItems(results.hits.filter(function (hit) {\n          return hit._geoloc;\n        })) : [];\n\n        if (!sendEvent) {\n          sendEvent = createSendEventForHits({\n            instantSearchInstance: instantSearchInstance,\n            index: helper.getIndex(),\n            widgetType: $$type\n          });\n        }\n\n        return {\n          items: items,\n          position: getPositionFromState(state),\n          currentRefinement: getCurrentRefinementFromState(state),\n          refine: refine(helper),\n          sendEvent: sendEvent,\n          clearMapRefinement: clearMapRefinement(helper),\n          isRefinedWithMap: isRefinedWithMap(state),\n          toggleRefineOnMapMove: toggleRefineOnMapMove,\n          isRefineOnMapMove: isRefineOnMapMove,\n          setMapMoveSinceLastRefine: setMapMoveSinceLastRefine,\n          hasMapMoveSinceLastRefine: hasMapMoveSinceLastRefine,\n          widgetParams: widgetParams\n        };\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return _objectSpread(_objectSpread({}, renderState), {}, {\n          geoSearch: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      dispose: function dispose(_ref3) {\n        var state = _ref3.state;\n        unmountFn();\n        return state.setQueryParameter('insideBoundingBox', undefined);\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref4) {\n        var searchParameters = _ref4.searchParameters;\n        var boundingBox = getBoundingBoxAsString(searchParameters);\n\n        if (!boundingBox || uiState && uiState.geoSearch && uiState.geoSearch.boundingBox === boundingBox) {\n          return uiState;\n        }\n\n        return _objectSpread(_objectSpread({}, uiState), {}, {\n          geoSearch: {\n            boundingBox: boundingBox\n          }\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref5) {\n        var uiState = _ref5.uiState;\n\n        if (!uiState || !uiState.geoSearch) {\n          return searchParameters.setQueryParameter('insideBoundingBox', undefined);\n        }\n\n        return setBoundingBoxAsString(searchParameters, uiState.geoSearch.boundingBox);\n      }\n    };\n  };\n};\n\nexport default connectGeoSearch;","map":{"version":3,"sources":["/Users/adil/Documents/GitHub/furniture-front/node_modules/instantsearch.js/es/connectors/geo-search/connectGeoSearch.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","checkRendering","aroundLatLngToPosition","insideBoundingBoxToBoundingBox","createDocumentationMessageGenerator","createSendEventForHits","noop","withUsage","name","connector","getBoundingBoxAsString","state","insideBoundingBox","setBoundingBoxAsString","setQueryParameter","$$type","connectGeoSearch","renderFn","unmountFn","undefined","widgetParams","_ref","_ref$enableRefineOnMa","enableRefineOnMapMove","_ref$transformItems","transformItems","items","widgetState","isRefineOnMapMove","hasMapMoveSinceLastRefine","lastRefinePosition","lastRefineBoundingBox","internalToggleRefineOnMapMove","internalSetMapMoveSinceLastRefine","getPositionFromState","aroundLatLng","getCurrentRefinementFromState","refine","helper","_ref2","ne","northEast","sw","southWest","boundingBox","lat","lng","join","setState","resetPage","search","clearMapRefinement","isRefinedWithMap","Boolean","toggleRefineOnMapMove","createInternalToggleRefinementOnMapMove","renderOptions","render","setMapMoveSinceLastRefine","createInternalSetMapMoveSinceLastRefine","shouldTriggerRender","sendEvent","init","initArgs","instantSearchInstance","isFirstRendering","getWidgetRenderState","renderArgs","positionChangedSinceLastRefine","boundingBoxChangedSinceLastRefine","bind","widgetRenderState","results","hits","hit","_geoloc","index","getIndex","widgetType","position","currentRefinement","getRenderState","renderState","geoSearch","dispose","_ref3","getWidgetUiState","uiState","_ref4","searchParameters","getWidgetSearchParameters","_ref5"],"mappings":"AAAA,SAASA,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;AAAE,MAAIC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYF,MAAZ,CAAX;;AAAgC,MAAIG,MAAM,CAACC,qBAAX,EAAkC;AAAE,QAAIC,OAAO,GAAGF,MAAM,CAACC,qBAAP,CAA6BJ,MAA7B,CAAd;AAAoD,QAAIC,cAAJ,EAAoBI,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;AAAE,aAAOJ,MAAM,CAACK,wBAAP,CAAgCR,MAAhC,EAAwCO,GAAxC,EAA6CE,UAApD;AAAiE,KAAjG,CAAV;AAA8GP,IAAAA,IAAI,CAACQ,IAAL,CAAUC,KAAV,CAAgBT,IAAhB,EAAsBG,OAAtB;AAAiC;;AAAC,SAAOH,IAAP;AAAc;;AAErV,SAASU,aAAT,CAAuBC,MAAvB,EAA+B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;;AAAuD,QAAIA,CAAC,GAAG,CAAR,EAAW;AAAEf,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BC,OAA9B,CAAsC,UAAUC,GAAV,EAAe;AAAEC,QAAAA,eAAe,CAACP,MAAD,EAASM,GAAT,EAAcF,MAAM,CAACE,GAAD,CAApB,CAAf;AAA4C,OAAnG;AAAuG,KAApH,MAA0H,IAAIhB,MAAM,CAACkB,yBAAX,EAAsC;AAAElB,MAAAA,MAAM,CAACmB,gBAAP,CAAwBT,MAAxB,EAAgCV,MAAM,CAACkB,yBAAP,CAAiCJ,MAAjC,CAAhC;AAA4E,KAApH,MAA0H;AAAElB,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AAAEhB,QAAAA,MAAM,CAACoB,cAAP,CAAsBV,MAAtB,EAA8BM,GAA9B,EAAmChB,MAAM,CAACK,wBAAP,CAAgCS,MAAhC,EAAwCE,GAAxC,CAAnC;AAAmF,OAApI;AAAwI;AAAE;;AAAC,SAAON,MAAP;AAAgB;;AAEthB,SAASO,eAAT,CAAyBI,GAAzB,EAA8BL,GAA9B,EAAmCM,KAAnC,EAA0C;AAAE,MAAIN,GAAG,IAAIK,GAAX,EAAgB;AAAErB,IAAAA,MAAM,CAACoB,cAAP,CAAsBC,GAAtB,EAA2BL,GAA3B,EAAgC;AAAEM,MAAAA,KAAK,EAAEA,KAAT;AAAgBhB,MAAAA,UAAU,EAAE,IAA5B;AAAkCiB,MAAAA,YAAY,EAAE,IAAhD;AAAsDC,MAAAA,QAAQ,EAAE;AAAhE,KAAhC;AAA0G,GAA5H,MAAkI;AAAEH,IAAAA,GAAG,CAACL,GAAD,CAAH,GAAWM,KAAX;AAAmB;;AAAC,SAAOD,GAAP;AAAa;;AAEjN,SAASI,cAAT,EAAyBC,sBAAzB,EAAiDC,8BAAjD,EAAiFC,mCAAjF,EAAsHC,sBAAtH,EAA8IC,IAA9I,QAA0J,iBAA1J;AACA,IAAIC,SAAS,GAAGH,mCAAmC,CAAC;AAClDI,EAAAA,IAAI,EAAE,YAD4C;AAElDC,EAAAA,SAAS,EAAE;AAFuC,CAAD,CAAnD,C,CAGI;AACJ;AACA;;AAEA,SAASC,sBAAT,CAAgCC,KAAhC,EAAuC;AACrC,SAAOA,KAAK,CAACC,iBAAN,IAA2B,EAAlC;AACD;;AAED,SAASC,sBAAT,CAAgCF,KAAhC,EAAuCb,KAAvC,EAA8C;AAC5C,SAAOa,KAAK,CAACG,iBAAN,CAAwB,mBAAxB,EAA6ChB,KAA7C,CAAP;AACD;;AAED,IAAIiB,MAAM,GAAG,eAAb;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,gBAAgB,GAAG,SAASA,gBAAT,CAA0BC,QAA1B,EAAoC;AACzD,MAAIC,SAAS,GAAG9B,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiB+B,SAAzC,GAAqD/B,SAAS,CAAC,CAAD,CAA9D,GAAoEkB,IAApF;AACAL,EAAAA,cAAc,CAACgB,QAAD,EAAWV,SAAS,EAApB,CAAd;AACA,SAAO,UAAUa,YAAV,EAAwB;AAC7B,QAAIC,IAAI,GAAGD,YAAY,IAAI,EAA3B;AAAA,QACIE,qBAAqB,GAAGD,IAAI,CAACE,qBADjC;AAAA,QAEIA,qBAAqB,GAAGD,qBAAqB,KAAK,KAAK,CAA/B,GAAmC,IAAnC,GAA0CA,qBAFtE;AAAA,QAGIE,mBAAmB,GAAGH,IAAI,CAACI,cAH/B;AAAA,QAIIA,cAAc,GAAGD,mBAAmB,KAAK,KAAK,CAA7B,GAAiC,UAAUE,KAAV,EAAiB;AACrE,aAAOA,KAAP;AACD,KAFoB,GAEjBF,mBANJ;;AAQA,QAAIG,WAAW,GAAG;AAChBC,MAAAA,iBAAiB,EAAEL,qBADH;AAEhB;AACAM,MAAAA,yBAAyB,EAAE,KAHX;AAIhBC,MAAAA,kBAAkB,EAAE,EAJJ;AAKhBC,MAAAA,qBAAqB,EAAE,EALP;AAMhBC,MAAAA,6BAA6B,EAAE1B,IANf;AAOhB2B,MAAAA,iCAAiC,EAAE3B;AAPnB,KAAlB;;AAUA,QAAI4B,oBAAoB,GAAG,SAASA,oBAAT,CAA8BvB,KAA9B,EAAqC;AAC9D,aAAOA,KAAK,CAACwB,YAAN,GAAqBjC,sBAAsB,CAACS,KAAK,CAACwB,YAAP,CAA3C,GAAkEhB,SAAzE;AACD,KAFD;;AAIA,QAAIiB,6BAA6B,GAAG,SAASA,6BAAT,CAAuCzB,KAAvC,EAA8C;AAChF,aAAOA,KAAK,CAACC,iBAAN,IAA2BT,8BAA8B,CAACQ,KAAK,CAACC,iBAAP,CAAhE;AACD,KAFD;;AAIA,QAAIyB,MAAM,GAAG,SAASA,MAAT,CAAgBC,MAAhB,EAAwB;AACnC,aAAO,UAAUC,KAAV,EAAiB;AACtB,YAAIC,EAAE,GAAGD,KAAK,CAACE,SAAf;AAAA,YACIC,EAAE,GAAGH,KAAK,CAACI,SADf;AAEA,YAAIC,WAAW,GAAG,CAACJ,EAAE,CAACK,GAAJ,EAASL,EAAE,CAACM,GAAZ,EAAiBJ,EAAE,CAACG,GAApB,EAAyBH,EAAE,CAACI,GAA5B,EAAiCC,IAAjC,EAAlB;AACAT,QAAAA,MAAM,CAACU,QAAP,CAAgBnC,sBAAsB,CAACyB,MAAM,CAAC3B,KAAR,EAAeiC,WAAf,CAAtB,CAAkDK,SAAlD,EAAhB,EAA+EC,MAA/E;AACAvB,QAAAA,WAAW,CAACE,yBAAZ,GAAwC,KAAxC;AACAF,QAAAA,WAAW,CAACI,qBAAZ,GAAoCa,WAApC;AACD,OAPD;AAQD,KATD;;AAWA,QAAIO,kBAAkB,GAAG,SAASA,kBAAT,CAA4Bb,MAA5B,EAAoC;AAC3D,aAAO,YAAY;AACjBA,QAAAA,MAAM,CAACxB,iBAAP,CAAyB,mBAAzB,EAA8CK,SAA9C,EAAyD+B,MAAzD;AACD,OAFD;AAGD,KAJD;;AAMA,QAAIE,gBAAgB,GAAG,SAASA,gBAAT,CAA0BzC,KAA1B,EAAiC;AACtD,aAAO,YAAY;AACjB,eAAO0C,OAAO,CAAC1C,KAAK,CAACC,iBAAP,CAAd;AACD,OAFD;AAGD,KAJD;;AAMA,QAAI0C,qBAAqB,GAAG,SAASA,qBAAT,GAAiC;AAC3D,aAAO3B,WAAW,CAACK,6BAAZ,EAAP;AACD,KAFD;;AAIA,QAAIuB,uCAAuC,GAAG,SAASA,uCAAT,CAAiDC,aAAjD,EAAgEC,MAAhE,EAAwE;AACpH,aAAO,YAAY;AACjB9B,QAAAA,WAAW,CAACC,iBAAZ,GAAgC,CAACD,WAAW,CAACC,iBAA7C;AACA6B,QAAAA,MAAM,CAACD,aAAD,CAAN;AACD,OAHD;AAID,KALD;;AAOA,QAAI5B,iBAAiB,GAAG,SAASA,iBAAT,GAA6B;AACnD,aAAOD,WAAW,CAACC,iBAAnB;AACD,KAFD;;AAIA,QAAI8B,yBAAyB,GAAG,SAASA,yBAAT,GAAqC;AACnE,aAAO/B,WAAW,CAACM,iCAAZ,EAAP;AACD,KAFD;;AAIA,QAAI0B,uCAAuC,GAAG,SAASA,uCAAT,CAAiDH,aAAjD,EAAgEC,MAAhE,EAAwE;AACpH,aAAO,YAAY;AACjB,YAAIG,mBAAmB,GAAGjC,WAAW,CAACE,yBAAZ,KAA0C,IAApE;AACAF,QAAAA,WAAW,CAACE,yBAAZ,GAAwC,IAAxC;;AAEA,YAAI+B,mBAAJ,EAAyB;AACvBH,UAAAA,MAAM,CAACD,aAAD,CAAN;AACD;AACF,OAPD;AAQD,KATD;;AAWA,QAAI3B,yBAAyB,GAAG,SAASA,yBAAT,GAAqC;AACnE,aAAOF,WAAW,CAACE,yBAAnB;AACD,KAFD;;AAIA,QAAIgC,SAAJ;AACA,WAAO;AACL9C,MAAAA,MAAM,EAAEA,MADH;AAEL+C,MAAAA,IAAI,EAAE,SAASA,IAAT,CAAcC,QAAd,EAAwB;AAC5B,YAAIC,qBAAqB,GAAGD,QAAQ,CAACC,qBAArC;AACA,YAAIC,gBAAgB,GAAG,IAAvB;AACAtC,QAAAA,WAAW,CAACK,6BAAZ,GAA4CuB,uCAAuC,CAACQ,QAAD,EAAWzD,IAAX,CAAnF;AACAqB,QAAAA,WAAW,CAACM,iCAAZ,GAAgD0B,uCAAuC,CAACI,QAAD,EAAWzD,IAAX,CAAvF;AACAW,QAAAA,QAAQ,CAAChC,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK,KAAKiF,oBAAL,CAA0BH,QAA1B,CAAL,CAAd,EAAyD,EAAzD,EAA6D;AACjFC,UAAAA,qBAAqB,EAAEA;AAD0D,SAA7D,CAAd,EAEJC,gBAFI,CAAR;AAGD,OAVI;AAWLR,MAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBU,UAAhB,EAA4B;AAClC,YAAI7B,MAAM,GAAG6B,UAAU,CAAC7B,MAAxB;AAAA,YACI0B,qBAAqB,GAAGG,UAAU,CAACH,qBADvC;AAEA,YAAIC,gBAAgB,GAAG,KAAvB,CAHkC,CAGJ;AAC9B;;AAEA,YAAItD,KAAK,GAAG2B,MAAM,CAAC3B,KAAnB;AACA,YAAIyD,8BAA8B,GAAGf,OAAO,CAAC1C,KAAK,CAACwB,YAAP,CAAP,IAA+BkB,OAAO,CAAC1B,WAAW,CAACG,kBAAb,CAAtC,IAA0EnB,KAAK,CAACwB,YAAN,KAAuBR,WAAW,CAACG,kBAAlJ;AACA,YAAIuC,iCAAiC,GAAG,CAAC1D,KAAK,CAACC,iBAAP,IAA4ByC,OAAO,CAAC1B,WAAW,CAACI,qBAAb,CAAnC,IAA0EpB,KAAK,CAACC,iBAAN,KAA4Be,WAAW,CAACI,qBAA1J;;AAEA,YAAIqC,8BAA8B,IAAIC,iCAAtC,EAAyE;AACvE1C,UAAAA,WAAW,CAACE,yBAAZ,GAAwC,KAAxC;AACD;;AAEDF,QAAAA,WAAW,CAACG,kBAAZ,GAAiCnB,KAAK,CAACwB,YAAN,IAAsB,EAAvD;AACAR,QAAAA,WAAW,CAACI,qBAAZ,GAAoCrB,sBAAsB,CAACC,KAAD,CAA1D;AACAgB,QAAAA,WAAW,CAACK,6BAAZ,GAA4CuB,uCAAuC,CAACY,UAAD,EAAa,KAAKV,MAAL,CAAYa,IAAZ,CAAiB,IAAjB,CAAb,CAAnF;AACA3C,QAAAA,WAAW,CAACM,iCAAZ,GAAgD0B,uCAAuC,CAACQ,UAAD,EAAa,KAAKV,MAAL,CAAYa,IAAZ,CAAiB,IAAjB,CAAb,CAAvF;AACA,YAAIC,iBAAiB,GAAG,KAAKL,oBAAL,CAA0BC,UAA1B,CAAxB;AACAN,QAAAA,SAAS,CAAC,MAAD,EAASU,iBAAiB,CAAC7C,KAA3B,CAAT;AACAT,QAAAA,QAAQ,CAAChC,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKsF,iBAAL,CAAd,EAAuC,EAAvC,EAA2C;AAC/DP,UAAAA,qBAAqB,EAAEA;AADwC,SAA3C,CAAd,EAEJC,gBAFI,CAAR;AAGD,OAlCI;AAmCLC,MAAAA,oBAAoB,EAAE,SAASA,oBAAT,CAA8BV,aAA9B,EAA6C;AACjE,YAAIlB,MAAM,GAAGkB,aAAa,CAAClB,MAA3B;AAAA,YACIkC,OAAO,GAAGhB,aAAa,CAACgB,OAD5B;AAAA,YAEIR,qBAAqB,GAAGR,aAAa,CAACQ,qBAF1C;AAGA,YAAIrD,KAAK,GAAG2B,MAAM,CAAC3B,KAAnB;AACA,YAAIe,KAAK,GAAG8C,OAAO,GAAG/C,cAAc,CAAC+C,OAAO,CAACC,IAAR,CAAa9F,MAAb,CAAoB,UAAU+F,GAAV,EAAe;AACtE,iBAAOA,GAAG,CAACC,OAAX;AACD,SAFoC,CAAD,CAAjB,GAEb,EAFN;;AAIA,YAAI,CAACd,SAAL,EAAgB;AACdA,UAAAA,SAAS,GAAGxD,sBAAsB,CAAC;AACjC2D,YAAAA,qBAAqB,EAAEA,qBADU;AAEjCY,YAAAA,KAAK,EAAEtC,MAAM,CAACuC,QAAP,EAF0B;AAGjCC,YAAAA,UAAU,EAAE/D;AAHqB,WAAD,CAAlC;AAKD;;AAED,eAAO;AACLW,UAAAA,KAAK,EAAEA,KADF;AAELqD,UAAAA,QAAQ,EAAE7C,oBAAoB,CAACvB,KAAD,CAFzB;AAGLqE,UAAAA,iBAAiB,EAAE5C,6BAA6B,CAACzB,KAAD,CAH3C;AAIL0B,UAAAA,MAAM,EAAEA,MAAM,CAACC,MAAD,CAJT;AAKLuB,UAAAA,SAAS,EAAEA,SALN;AAMLV,UAAAA,kBAAkB,EAAEA,kBAAkB,CAACb,MAAD,CANjC;AAOLc,UAAAA,gBAAgB,EAAEA,gBAAgB,CAACzC,KAAD,CAP7B;AAQL2C,UAAAA,qBAAqB,EAAEA,qBARlB;AASL1B,UAAAA,iBAAiB,EAAEA,iBATd;AAUL8B,UAAAA,yBAAyB,EAAEA,yBAVtB;AAWL7B,UAAAA,yBAAyB,EAAEA,yBAXtB;AAYLT,UAAAA,YAAY,EAAEA;AAZT,SAAP;AAcD,OAlEI;AAmEL6D,MAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBC,WAAxB,EAAqC1B,aAArC,EAAoD;AAClE,eAAOvE,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKiG,WAAL,CAAd,EAAiC,EAAjC,EAAqC;AACvDC,UAAAA,SAAS,EAAE,KAAKjB,oBAAL,CAA0BV,aAA1B;AAD4C,SAArC,CAApB;AAGD,OAvEI;AAwEL4B,MAAAA,OAAO,EAAE,SAASA,OAAT,CAAiBC,KAAjB,EAAwB;AAC/B,YAAI1E,KAAK,GAAG0E,KAAK,CAAC1E,KAAlB;AACAO,QAAAA,SAAS;AACT,eAAOP,KAAK,CAACG,iBAAN,CAAwB,mBAAxB,EAA6CK,SAA7C,CAAP;AACD,OA5EI;AA6ELmE,MAAAA,gBAAgB,EAAE,SAASA,gBAAT,CAA0BC,OAA1B,EAAmCC,KAAnC,EAA0C;AAC1D,YAAIC,gBAAgB,GAAGD,KAAK,CAACC,gBAA7B;AACA,YAAI7C,WAAW,GAAGlC,sBAAsB,CAAC+E,gBAAD,CAAxC;;AAEA,YAAI,CAAC7C,WAAD,IAAgB2C,OAAO,IAAIA,OAAO,CAACJ,SAAnB,IAAgCI,OAAO,CAACJ,SAAR,CAAkBvC,WAAlB,KAAkCA,WAAtF,EAAmG;AACjG,iBAAO2C,OAAP;AACD;;AAED,eAAOtG,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKsG,OAAL,CAAd,EAA6B,EAA7B,EAAiC;AACnDJ,UAAAA,SAAS,EAAE;AACTvC,YAAAA,WAAW,EAAEA;AADJ;AADwC,SAAjC,CAApB;AAKD,OA1FI;AA2FL8C,MAAAA,yBAAyB,EAAE,SAASA,yBAAT,CAAmCD,gBAAnC,EAAqDE,KAArD,EAA4D;AACrF,YAAIJ,OAAO,GAAGI,KAAK,CAACJ,OAApB;;AAEA,YAAI,CAACA,OAAD,IAAY,CAACA,OAAO,CAACJ,SAAzB,EAAoC;AAClC,iBAAOM,gBAAgB,CAAC3E,iBAAjB,CAAmC,mBAAnC,EAAwDK,SAAxD,CAAP;AACD;;AAED,eAAON,sBAAsB,CAAC4E,gBAAD,EAAmBF,OAAO,CAACJ,SAAR,CAAkBvC,WAArC,CAA7B;AACD;AAnGI,KAAP;AAqGD,GA1LD;AA2LD,CA9LD;;AAgMA,eAAe5B,gBAAf","sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { checkRendering, aroundLatLngToPosition, insideBoundingBoxToBoundingBox, createDocumentationMessageGenerator, createSendEventForHits, noop } from '../../lib/utils';\nvar withUsage = createDocumentationMessageGenerator({\n  name: 'geo-search',\n  connector: true\n}); // in this connector, we assume insideBoundingBox is only a string,\n// even though in the helper it's defined as number[][] alone.\n// This can be done, since the connector assumes \"control\" of the parameter\n\nfunction getBoundingBoxAsString(state) {\n  return state.insideBoundingBox || '';\n}\n\nfunction setBoundingBoxAsString(state, value) {\n  return state.setQueryParameter('insideBoundingBox', value);\n}\n\nvar $$type = 'ais.geoSearch';\n\n/**\n * The **GeoSearch** connector provides the logic to build a widget that will display the results on a map. It also provides a way to search for results based on their position. The connector provides functions to manage the search experience (search on map interaction or control the interaction for example).\n *\n * @requirements\n *\n * Note that the GeoSearch connector uses the [geosearch](https://www.algolia.com/doc/guides/searching/geo-search) capabilities of Algolia. Your hits **must** have a `_geoloc` attribute in order to be passed to the rendering function.\n *\n * Currently, the feature is not compatible with multiple values in the _geoloc attribute.\n */\nvar connectGeoSearch = function connectGeoSearch(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  checkRendering(renderFn, withUsage());\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n        _ref$enableRefineOnMa = _ref.enableRefineOnMapMove,\n        enableRefineOnMapMove = _ref$enableRefineOnMa === void 0 ? true : _ref$enableRefineOnMa,\n        _ref$transformItems = _ref.transformItems,\n        transformItems = _ref$transformItems === void 0 ? function (items) {\n      return items;\n    } : _ref$transformItems;\n\n    var widgetState = {\n      isRefineOnMapMove: enableRefineOnMapMove,\n      // @MAJOR hasMapMoveSinceLastRefine -> hasMapMovedSinceLastRefine\n      hasMapMoveSinceLastRefine: false,\n      lastRefinePosition: '',\n      lastRefineBoundingBox: '',\n      internalToggleRefineOnMapMove: noop,\n      internalSetMapMoveSinceLastRefine: noop\n    };\n\n    var getPositionFromState = function getPositionFromState(state) {\n      return state.aroundLatLng ? aroundLatLngToPosition(state.aroundLatLng) : undefined;\n    };\n\n    var getCurrentRefinementFromState = function getCurrentRefinementFromState(state) {\n      return state.insideBoundingBox && insideBoundingBoxToBoundingBox(state.insideBoundingBox);\n    };\n\n    var refine = function refine(helper) {\n      return function (_ref2) {\n        var ne = _ref2.northEast,\n            sw = _ref2.southWest;\n        var boundingBox = [ne.lat, ne.lng, sw.lat, sw.lng].join();\n        helper.setState(setBoundingBoxAsString(helper.state, boundingBox).resetPage()).search();\n        widgetState.hasMapMoveSinceLastRefine = false;\n        widgetState.lastRefineBoundingBox = boundingBox;\n      };\n    };\n\n    var clearMapRefinement = function clearMapRefinement(helper) {\n      return function () {\n        helper.setQueryParameter('insideBoundingBox', undefined).search();\n      };\n    };\n\n    var isRefinedWithMap = function isRefinedWithMap(state) {\n      return function () {\n        return Boolean(state.insideBoundingBox);\n      };\n    };\n\n    var toggleRefineOnMapMove = function toggleRefineOnMapMove() {\n      return widgetState.internalToggleRefineOnMapMove();\n    };\n\n    var createInternalToggleRefinementOnMapMove = function createInternalToggleRefinementOnMapMove(renderOptions, render) {\n      return function () {\n        widgetState.isRefineOnMapMove = !widgetState.isRefineOnMapMove;\n        render(renderOptions);\n      };\n    };\n\n    var isRefineOnMapMove = function isRefineOnMapMove() {\n      return widgetState.isRefineOnMapMove;\n    };\n\n    var setMapMoveSinceLastRefine = function setMapMoveSinceLastRefine() {\n      return widgetState.internalSetMapMoveSinceLastRefine();\n    };\n\n    var createInternalSetMapMoveSinceLastRefine = function createInternalSetMapMoveSinceLastRefine(renderOptions, render) {\n      return function () {\n        var shouldTriggerRender = widgetState.hasMapMoveSinceLastRefine !== true;\n        widgetState.hasMapMoveSinceLastRefine = true;\n\n        if (shouldTriggerRender) {\n          render(renderOptions);\n        }\n      };\n    };\n\n    var hasMapMoveSinceLastRefine = function hasMapMoveSinceLastRefine() {\n      return widgetState.hasMapMoveSinceLastRefine;\n    };\n\n    var sendEvent;\n    return {\n      $$type: $$type,\n      init: function init(initArgs) {\n        var instantSearchInstance = initArgs.instantSearchInstance;\n        var isFirstRendering = true;\n        widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementOnMapMove(initArgs, noop);\n        widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(initArgs, noop);\n        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(initArgs)), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), isFirstRendering);\n      },\n      render: function render(renderArgs) {\n        var helper = renderArgs.helper,\n            instantSearchInstance = renderArgs.instantSearchInstance;\n        var isFirstRendering = false; // We don't use the state provided by the render function because we need\n        // to be sure that the state is the latest one for the following condition\n\n        var state = helper.state;\n        var positionChangedSinceLastRefine = Boolean(state.aroundLatLng) && Boolean(widgetState.lastRefinePosition) && state.aroundLatLng !== widgetState.lastRefinePosition;\n        var boundingBoxChangedSinceLastRefine = !state.insideBoundingBox && Boolean(widgetState.lastRefineBoundingBox) && state.insideBoundingBox !== widgetState.lastRefineBoundingBox;\n\n        if (positionChangedSinceLastRefine || boundingBoxChangedSinceLastRefine) {\n          widgetState.hasMapMoveSinceLastRefine = false;\n        }\n\n        widgetState.lastRefinePosition = state.aroundLatLng || '';\n        widgetState.lastRefineBoundingBox = getBoundingBoxAsString(state);\n        widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementOnMapMove(renderArgs, this.render.bind(this));\n        widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(renderArgs, this.render.bind(this));\n        var widgetRenderState = this.getWidgetRenderState(renderArgs);\n        sendEvent('view', widgetRenderState.items);\n        renderFn(_objectSpread(_objectSpread({}, widgetRenderState), {}, {\n          instantSearchInstance: instantSearchInstance\n        }), isFirstRendering);\n      },\n      getWidgetRenderState: function getWidgetRenderState(renderOptions) {\n        var helper = renderOptions.helper,\n            results = renderOptions.results,\n            instantSearchInstance = renderOptions.instantSearchInstance;\n        var state = helper.state;\n        var items = results ? transformItems(results.hits.filter(function (hit) {\n          return hit._geoloc;\n        })) : [];\n\n        if (!sendEvent) {\n          sendEvent = createSendEventForHits({\n            instantSearchInstance: instantSearchInstance,\n            index: helper.getIndex(),\n            widgetType: $$type\n          });\n        }\n\n        return {\n          items: items,\n          position: getPositionFromState(state),\n          currentRefinement: getCurrentRefinementFromState(state),\n          refine: refine(helper),\n          sendEvent: sendEvent,\n          clearMapRefinement: clearMapRefinement(helper),\n          isRefinedWithMap: isRefinedWithMap(state),\n          toggleRefineOnMapMove: toggleRefineOnMapMove,\n          isRefineOnMapMove: isRefineOnMapMove,\n          setMapMoveSinceLastRefine: setMapMoveSinceLastRefine,\n          hasMapMoveSinceLastRefine: hasMapMoveSinceLastRefine,\n          widgetParams: widgetParams\n        };\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return _objectSpread(_objectSpread({}, renderState), {}, {\n          geoSearch: this.getWidgetRenderState(renderOptions)\n        });\n      },\n      dispose: function dispose(_ref3) {\n        var state = _ref3.state;\n        unmountFn();\n        return state.setQueryParameter('insideBoundingBox', undefined);\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref4) {\n        var searchParameters = _ref4.searchParameters;\n        var boundingBox = getBoundingBoxAsString(searchParameters);\n\n        if (!boundingBox || uiState && uiState.geoSearch && uiState.geoSearch.boundingBox === boundingBox) {\n          return uiState;\n        }\n\n        return _objectSpread(_objectSpread({}, uiState), {}, {\n          geoSearch: {\n            boundingBox: boundingBox\n          }\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref5) {\n        var uiState = _ref5.uiState;\n\n        if (!uiState || !uiState.geoSearch) {\n          return searchParameters.setQueryParameter('insideBoundingBox', undefined);\n        }\n\n        return setBoundingBoxAsString(searchParameters, uiState.geoSearch.boundingBox);\n      }\n    };\n  };\n};\n\nexport default connectGeoSearch;"]},"metadata":{},"sourceType":"module"}