{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport React, { Fragment } from 'react';\nimport { getDisplayName } from '../core/utils';\nimport connectDynamicWidgets from '../connectors/connectDynamicWidgets';\n\nfunction getAttribute(component) {\n  if (_typeof(component) !== 'object') {\n    return undefined;\n  }\n\n  if (component.props.attribute) {\n    return component.props.attribute;\n  }\n\n  if (Array.isArray(component.props.attributes)) {\n    return component.props.attributes[0];\n  }\n\n  if (component.props.children) {\n    return getAttribute(React.Children.only(component.props.children));\n  }\n\n  return undefined;\n}\n\nfunction DynamicWidgets(_ref) {\n  var children = _ref.children,\n      attributesToRender = _ref.attributesToRender,\n      _ref$fallbackComponen = _ref.fallbackComponent,\n      Fallback = _ref$fallbackComponen === void 0 ? function () {\n    return null;\n  } : _ref$fallbackComponen;\n  var widgets = new Map();\n  React.Children.forEach(children, function (child) {\n    var attribute = getAttribute(child);\n\n    if (!attribute) {\n      throw new Error(\"Could not find \\\"attribute\\\" prop for \".concat(getDisplayName(child), \".\"));\n    }\n\n    widgets.set(attribute, child);\n  }); // on initial render this will be empty, but React InstantSearch keeps\n  // search state for unmounted components in place, so routing works.\n\n  return React.createElement(React.Fragment, null, attributesToRender.map(function (attribute) {\n    return React.createElement(Fragment, {\n      key: attribute\n    }, widgets.get(attribute) || React.createElement(Fallback, {\n      attribute: attribute\n    }));\n  }));\n}\n\nexport default connectDynamicWidgets(DynamicWidgets);","map":{"version":3,"sources":["/Users/adil/Documents/GitHub/furniture-front/node_modules/react-instantsearch-core/dist/es/widgets/DynamicWidgets.js"],"names":["_typeof","React","Fragment","getDisplayName","connectDynamicWidgets","getAttribute","component","undefined","props","attribute","Array","isArray","attributes","children","Children","only","DynamicWidgets","_ref","attributesToRender","_ref$fallbackComponen","fallbackComponent","Fallback","widgets","Map","forEach","child","Error","concat","set","createElement","map","key","get"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,mCAApB;AACA,OAAOC,KAAP,IAAgBC,QAAhB,QAAgC,OAAhC;AACA,SAASC,cAAT,QAA+B,eAA/B;AACA,OAAOC,qBAAP,MAAkC,qCAAlC;;AAEA,SAASC,YAAT,CAAsBC,SAAtB,EAAiC;AAC/B,MAAIN,OAAO,CAACM,SAAD,CAAP,KAAuB,QAA3B,EAAqC;AACnC,WAAOC,SAAP;AACD;;AAED,MAAID,SAAS,CAACE,KAAV,CAAgBC,SAApB,EAA+B;AAC7B,WAAOH,SAAS,CAACE,KAAV,CAAgBC,SAAvB;AACD;;AAED,MAAIC,KAAK,CAACC,OAAN,CAAcL,SAAS,CAACE,KAAV,CAAgBI,UAA9B,CAAJ,EAA+C;AAC7C,WAAON,SAAS,CAACE,KAAV,CAAgBI,UAAhB,CAA2B,CAA3B,CAAP;AACD;;AAED,MAAIN,SAAS,CAACE,KAAV,CAAgBK,QAApB,EAA8B;AAC5B,WAAOR,YAAY,CAACJ,KAAK,CAACa,QAAN,CAAeC,IAAf,CAAoBT,SAAS,CAACE,KAAV,CAAgBK,QAApC,CAAD,CAAnB;AACD;;AAED,SAAON,SAAP;AACD;;AAED,SAASS,cAAT,CAAwBC,IAAxB,EAA8B;AAC5B,MAAIJ,QAAQ,GAAGI,IAAI,CAACJ,QAApB;AAAA,MACIK,kBAAkB,GAAGD,IAAI,CAACC,kBAD9B;AAAA,MAEIC,qBAAqB,GAAGF,IAAI,CAACG,iBAFjC;AAAA,MAGIC,QAAQ,GAAGF,qBAAqB,KAAK,KAAK,CAA/B,GAAmC,YAAY;AAC5D,WAAO,IAAP;AACD,GAFc,GAEXA,qBALJ;AAMA,MAAIG,OAAO,GAAG,IAAIC,GAAJ,EAAd;AACAtB,EAAAA,KAAK,CAACa,QAAN,CAAeU,OAAf,CAAuBX,QAAvB,EAAiC,UAAUY,KAAV,EAAiB;AAChD,QAAIhB,SAAS,GAAGJ,YAAY,CAACoB,KAAD,CAA5B;;AAEA,QAAI,CAAChB,SAAL,EAAgB;AACd,YAAM,IAAIiB,KAAJ,CAAU,yCAAyCC,MAAzC,CAAgDxB,cAAc,CAACsB,KAAD,CAA9D,EAAuE,GAAvE,CAAV,CAAN;AACD;;AAEDH,IAAAA,OAAO,CAACM,GAAR,CAAYnB,SAAZ,EAAuBgB,KAAvB;AACD,GARD,EAR4B,CAgBxB;AACJ;;AAEA,SAAOxB,KAAK,CAAC4B,aAAN,CAAoB5B,KAAK,CAACC,QAA1B,EAAoC,IAApC,EAA0CgB,kBAAkB,CAACY,GAAnB,CAAuB,UAAUrB,SAAV,EAAqB;AAC3F,WAAOR,KAAK,CAAC4B,aAAN,CAAoB3B,QAApB,EAA8B;AACnC6B,MAAAA,GAAG,EAAEtB;AAD8B,KAA9B,EAEJa,OAAO,CAACU,GAAR,CAAYvB,SAAZ,KAA0BR,KAAK,CAAC4B,aAAN,CAAoBR,QAApB,EAA8B;AACzDZ,MAAAA,SAAS,EAAEA;AAD8C,KAA9B,CAFtB,CAAP;AAKD,GANgD,CAA1C,CAAP;AAOD;;AAED,eAAeL,qBAAqB,CAACY,cAAD,CAApC","sourcesContent":["import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport React, { Fragment } from 'react';\nimport { getDisplayName } from '../core/utils';\nimport connectDynamicWidgets from '../connectors/connectDynamicWidgets';\n\nfunction getAttribute(component) {\n  if (_typeof(component) !== 'object') {\n    return undefined;\n  }\n\n  if (component.props.attribute) {\n    return component.props.attribute;\n  }\n\n  if (Array.isArray(component.props.attributes)) {\n    return component.props.attributes[0];\n  }\n\n  if (component.props.children) {\n    return getAttribute(React.Children.only(component.props.children));\n  }\n\n  return undefined;\n}\n\nfunction DynamicWidgets(_ref) {\n  var children = _ref.children,\n      attributesToRender = _ref.attributesToRender,\n      _ref$fallbackComponen = _ref.fallbackComponent,\n      Fallback = _ref$fallbackComponen === void 0 ? function () {\n    return null;\n  } : _ref$fallbackComponen;\n  var widgets = new Map();\n  React.Children.forEach(children, function (child) {\n    var attribute = getAttribute(child);\n\n    if (!attribute) {\n      throw new Error(\"Could not find \\\"attribute\\\" prop for \".concat(getDisplayName(child), \".\"));\n    }\n\n    widgets.set(attribute, child);\n  }); // on initial render this will be empty, but React InstantSearch keeps\n  // search state for unmounted components in place, so routing works.\n\n  return React.createElement(React.Fragment, null, attributesToRender.map(function (attribute) {\n    return React.createElement(Fragment, {\n      key: attribute\n    }, widgets.get(attribute) || React.createElement(Fallback, {\n      attribute: attribute\n    }));\n  }));\n}\n\nexport default connectDynamicWidgets(DynamicWidgets);"]},"metadata":{},"sourceType":"module"}