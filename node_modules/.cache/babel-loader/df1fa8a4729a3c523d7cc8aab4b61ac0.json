{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport isEqual from 'react-fast-compare';\nimport createConnector from '../core/createConnector';\nimport { getCurrentRefinementValue, refineValue, getResults } from '../core/indexUtils';\nimport { addAbsolutePositions, addQueryID } from '../core/utils';\n\nfunction getId() {\n  return 'page';\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  var id = getId();\n  var page = 1;\n  var currentRefinement = getCurrentRefinementValue(props, searchState, context, id, page);\n\n  if (typeof currentRefinement === 'string') {\n    return parseInt(currentRefinement, 10);\n  }\n\n  return currentRefinement;\n}\n\nfunction getStateWithoutPage(state) {\n  var _ref = state || {},\n      page = _ref.page,\n      rest = _objectWithoutProperties(_ref, [\"page\"]);\n\n  return rest;\n}\n\nfunction getInMemoryCache() {\n  var cachedHits = undefined;\n  var cachedState = undefined;\n  return {\n    read: function read(_ref2) {\n      var state = _ref2.state;\n      return isEqual(cachedState, getStateWithoutPage(state)) ? cachedHits : null;\n    },\n    write: function write(_ref3) {\n      var state = _ref3.state,\n          hits = _ref3.hits;\n      cachedState = getStateWithoutPage(state);\n      cachedHits = hits;\n    }\n  };\n}\n\nfunction extractHitsFromCachedHits(cachedHits) {\n  return Object.keys(cachedHits).map(Number).sort(function (a, b) {\n    return a - b;\n  }).reduce(function (acc, page) {\n    return acc.concat(cachedHits[page]);\n  }, []);\n}\n/**\n * InfiniteHits connector provides the logic to create connected\n * components that will render an continuous list of results retrieved from\n * Algolia. This connector provides a function to load more results.\n * @name connectInfiniteHits\n * @kind connector\n * @providedPropType {array.<object>} hits - the records that matched the search state\n * @providedPropType {boolean} hasMore - indicates if there are more pages to load\n * @providedPropType {function} refine - call to load more results\n */\n\n\nexport default createConnector({\n  displayName: 'AlgoliaInfiniteHits',\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var _this = this;\n\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n\n    if (!results) {\n      return {\n        hits: [],\n        hasPrevious: false,\n        hasMore: false,\n        refine: function refine() {},\n        refinePrevious: function refinePrevious() {},\n        refineNext: function refineNext() {}\n      };\n    }\n\n    var page = results.page,\n        hits = results.hits,\n        hitsPerPage = results.hitsPerPage,\n        nbPages = results.nbPages,\n        state = results._state;\n    this._cache = props.cache ? props.cache : this._cache || getInMemoryCache();\n    var cachedHits = this._cache.read({\n      state: state\n    }) || {};\n    var hitsWithPositions = addAbsolutePositions(hits, hitsPerPage, page);\n    var hitsWithPositionsAndQueryID = addQueryID(hitsWithPositions, results.queryID);\n    cachedHits[page] = hitsWithPositionsAndQueryID;\n\n    this._cache.write({\n      state: state,\n      hits: cachedHits\n    });\n    /*\n      Math.min() and Math.max() returns Infinity or -Infinity when no argument is given.\n      But there is always something in this point because of `cachedHits[page]`.\n    */\n\n\n    var firstReceivedPage = Math.min.apply(Math, _toConsumableArray(Object.keys(cachedHits).map(Number)));\n    var lastReceivedPage = Math.max.apply(Math, _toConsumableArray(Object.keys(cachedHits).map(Number)));\n    var hasPrevious = firstReceivedPage > 0;\n    var lastPageIndex = nbPages - 1;\n    var hasMore = lastReceivedPage < lastPageIndex;\n\n    var refinePrevious = function refinePrevious(event) {\n      return _this.refine(event, firstReceivedPage - 1);\n    };\n\n    var refineNext = function refineNext(event) {\n      return _this.refine(event, lastReceivedPage + 1);\n    };\n\n    return {\n      hits: extractHitsFromCachedHits(cachedHits),\n      hasPrevious: hasPrevious,\n      hasMore: hasMore,\n      refinePrevious: refinePrevious,\n      refineNext: refineNext\n    };\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    return searchParameters.setQueryParameters({\n      page: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      }) - 1\n    });\n  },\n  refine: function refine(props, searchState, event, index) {\n    var id = getId();\n\n    var nextValue = _defineProperty({}, id, index + 1);\n\n    var resetPage = false;\n    return refineValue(searchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, resetPage);\n  }\n});","map":{"version":3,"sources":["/Users/adil/Documents/GitHub/furniture-front/node_modules/react-instantsearch-core/dist/es/connectors/connectInfiniteHits.js"],"names":["_defineProperty","_toConsumableArray","_objectWithoutProperties","isEqual","createConnector","getCurrentRefinementValue","refineValue","getResults","addAbsolutePositions","addQueryID","getId","getCurrentRefinement","props","searchState","context","id","page","currentRefinement","parseInt","getStateWithoutPage","state","_ref","rest","getInMemoryCache","cachedHits","undefined","cachedState","read","_ref2","write","_ref3","hits","extractHitsFromCachedHits","Object","keys","map","Number","sort","a","b","reduce","acc","concat","displayName","getProvidedProps","searchResults","_this","results","ais","contextValue","multiIndexContext","indexContextValue","hasPrevious","hasMore","refine","refinePrevious","refineNext","hitsPerPage","nbPages","_state","_cache","cache","hitsWithPositions","hitsWithPositionsAndQueryID","queryID","firstReceivedPage","Math","min","apply","lastReceivedPage","max","lastPageIndex","event","getSearchParameters","searchParameters","setQueryParameters","index","nextValue","resetPage"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport isEqual from 'react-fast-compare';\nimport createConnector from '../core/createConnector';\nimport { getCurrentRefinementValue, refineValue, getResults } from '../core/indexUtils';\nimport { addAbsolutePositions, addQueryID } from '../core/utils';\n\nfunction getId() {\n  return 'page';\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  var id = getId();\n  var page = 1;\n  var currentRefinement = getCurrentRefinementValue(props, searchState, context, id, page);\n\n  if (typeof currentRefinement === 'string') {\n    return parseInt(currentRefinement, 10);\n  }\n\n  return currentRefinement;\n}\n\nfunction getStateWithoutPage(state) {\n  var _ref = state || {},\n      page = _ref.page,\n      rest = _objectWithoutProperties(_ref, [\"page\"]);\n\n  return rest;\n}\n\nfunction getInMemoryCache() {\n  var cachedHits = undefined;\n  var cachedState = undefined;\n  return {\n    read: function read(_ref2) {\n      var state = _ref2.state;\n      return isEqual(cachedState, getStateWithoutPage(state)) ? cachedHits : null;\n    },\n    write: function write(_ref3) {\n      var state = _ref3.state,\n          hits = _ref3.hits;\n      cachedState = getStateWithoutPage(state);\n      cachedHits = hits;\n    }\n  };\n}\n\nfunction extractHitsFromCachedHits(cachedHits) {\n  return Object.keys(cachedHits).map(Number).sort(function (a, b) {\n    return a - b;\n  }).reduce(function (acc, page) {\n    return acc.concat(cachedHits[page]);\n  }, []);\n}\n/**\n * InfiniteHits connector provides the logic to create connected\n * components that will render an continuous list of results retrieved from\n * Algolia. This connector provides a function to load more results.\n * @name connectInfiniteHits\n * @kind connector\n * @providedPropType {array.<object>} hits - the records that matched the search state\n * @providedPropType {boolean} hasMore - indicates if there are more pages to load\n * @providedPropType {function} refine - call to load more results\n */\n\n\nexport default createConnector({\n  displayName: 'AlgoliaInfiniteHits',\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var _this = this;\n\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n\n    if (!results) {\n      return {\n        hits: [],\n        hasPrevious: false,\n        hasMore: false,\n        refine: function refine() {},\n        refinePrevious: function refinePrevious() {},\n        refineNext: function refineNext() {}\n      };\n    }\n\n    var page = results.page,\n        hits = results.hits,\n        hitsPerPage = results.hitsPerPage,\n        nbPages = results.nbPages,\n        state = results._state;\n    this._cache = props.cache ? props.cache : this._cache || getInMemoryCache();\n    var cachedHits = this._cache.read({\n      state: state\n    }) || {};\n    var hitsWithPositions = addAbsolutePositions(hits, hitsPerPage, page);\n    var hitsWithPositionsAndQueryID = addQueryID(hitsWithPositions, results.queryID);\n    cachedHits[page] = hitsWithPositionsAndQueryID;\n\n    this._cache.write({\n      state: state,\n      hits: cachedHits\n    });\n    /*\n      Math.min() and Math.max() returns Infinity or -Infinity when no argument is given.\n      But there is always something in this point because of `cachedHits[page]`.\n    */\n\n\n    var firstReceivedPage = Math.min.apply(Math, _toConsumableArray(Object.keys(cachedHits).map(Number)));\n    var lastReceivedPage = Math.max.apply(Math, _toConsumableArray(Object.keys(cachedHits).map(Number)));\n    var hasPrevious = firstReceivedPage > 0;\n    var lastPageIndex = nbPages - 1;\n    var hasMore = lastReceivedPage < lastPageIndex;\n\n    var refinePrevious = function refinePrevious(event) {\n      return _this.refine(event, firstReceivedPage - 1);\n    };\n\n    var refineNext = function refineNext(event) {\n      return _this.refine(event, lastReceivedPage + 1);\n    };\n\n    return {\n      hits: extractHitsFromCachedHits(cachedHits),\n      hasPrevious: hasPrevious,\n      hasMore: hasMore,\n      refinePrevious: refinePrevious,\n      refineNext: refineNext\n    };\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    return searchParameters.setQueryParameters({\n      page: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      }) - 1\n    });\n  },\n  refine: function refine(props, searchState, event, index) {\n    var id = getId();\n\n    var nextValue = _defineProperty({}, id, index + 1);\n\n    var resetPage = false;\n    return refineValue(searchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, resetPage);\n  }\n});"]},"metadata":{},"sourceType":"module"}