{"ast":null,"code":"export default function (n) {\n  return {\n    all: n = n || new Map(),\n    on: function (t, e) {\n      var i = n.get(t);\n      i && i.push(e) || n.set(t, [e]);\n    },\n    off: function (t, e) {\n      var i = n.get(t);\n      i && i.splice(i.indexOf(e) >>> 0, 1);\n    },\n    emit: function (t, e) {\n      (n.get(t) || []).slice().map(function (n) {\n        n(e);\n      }), (n.get(\"*\") || []).slice().map(function (n) {\n        n(t, e);\n      });\n    }\n  };\n}","map":{"version":3,"sources":["../src/index.ts"],"names":["all","Map","on","type","handler","handlers","get","push","set","off","splice","indexOf","emit","evt","slice","map"],"mappings":"yBAgC6BA,C,EAAAA;AAG5B,SAAO;AAKNA,IAAAA,GAAAA,EAPDA,CAAAA,GAAMA,CAAAA,IAAO,IAAIC,GAAJ,EAEN;AAaNC,IAAAA,EAAAA,EAAAA,UAAYC,CAAZD,EAA6BE,CAA7BF,EAA6BE;AAC5B,UAAMC,CAAAA,GAAWL,CAAAA,CAAIM,GAAJN,CAAQG,CAARH,CAAjB;AACcK,MAAAA,CAAAA,IAAYA,CAAAA,CAASE,IAATF,CAAcD,CAAdC,CAAZA,IAEbL,CAAAA,CAAIQ,GAAJR,CAAQG,CAARH,EAAc,CAACI,CAAD,CAAdJ,CAFaK;AAEED,KAjBX;AA2BNK,IAAAA,GAAAA,EAAAA,UAAaN,CAAbM,EAA8BL,CAA9BK,EAA8BL;AAC7B,UAAMC,CAAAA,GAAWL,CAAAA,CAAIM,GAAJN,CAAQG,CAARH,CAAjB;AACIK,MAAAA,CAAAA,IACHA,CAAAA,CAASK,MAATL,CAAgBA,CAAAA,CAASM,OAATN,CAAiBD,CAAjBC,MAA8B,CAA9CA,EAAiD,CAAjDA,CADGA;AAC8C,KA9B7C;AA4CNO,IAAAA,IAAAA,EAAAA,UAAcT,CAAdS,EAA+BC,CAA/BD,EAA+BC;AAAAA,OAC5Bb,CAAAA,CAAIM,GAAJN,CAAQG,CAARH,KAAiB,EADWa,EACcC,KADdD,GACsBE,GADtBF,CAC0B,UAACT,CAAD,EAACA;AAAcA,QAAAA,CAAAA,CAAQS,CAART,CAAAA;AAAQS,OADjDA,GACiDA,CAC7Eb,CAAAA,CAAIM,GAAJN,CAAQ,GAARA,KAAgB,EAD6Da,EAC5BC,KAD4BD,GACpBE,GADoBF,CAChB,UAACT,CAAD,EAACA;AAAcA,QAAAA,CAAAA,CAAQD,CAARC,EAAcS,CAAdT,CAAAA;AAAcS,OADbA,CADjDA;AAE8DA;AA9CvF,GAAP;AA8C8FA","sourcesContent":["export type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = any> = (event?: T) => void;\nexport type WildcardHandler = (type: EventType, event?: any) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList = Array<Handler>;\nexport type WildCardEventHandlerList = Array<WildcardHandler>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap = Map<EventType, EventHandlerList | WildCardEventHandlerList>;\n\nexport interface Emitter {\n\tall: EventHandlerMap;\n\n\ton<T = any>(type: EventType, handler: Handler<T>): void;\n\ton(type: '*', handler: WildcardHandler): void;\n\n\toff<T = any>(type: EventType, handler: Handler<T>): void;\n\toff(type: '*', handler: WildcardHandler): void;\n\n\temit<T = any>(type: EventType, event?: T): void;\n\temit(type: '*', event?: any): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt(all?: EventHandlerMap): Emitter {\n\tall = all || new Map();\n\n\treturn {\n\n\t\t/**\n\t\t * A Map of event names to registered handler functions.\n\t\t */\n\t\tall,\n\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to listen for, or `\"*\"` for all events\n\t\t * @param {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton<T = any>(type: EventType, handler: Handler<T>) {\n\t\t\tconst handlers = all.get(type);\n\t\t\tconst added = handlers && handlers.push(handler);\n\t\t\tif (!added) {\n\t\t\t\tall.set(type, [handler]);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to unregister `handler` from, or `\"*\"`\n\t\t * @param {Function} handler Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff<T = any>(type: EventType, handler: Handler<T>) {\n\t\t\tconst handlers = all.get(type);\n\t\t\tif (handlers) {\n\t\t\t\thandlers.splice(handlers.indexOf(handler) >>> 0, 1);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `\"*\"` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * Note: Manually firing \"*\" handlers is not supported.\n\t\t *\n\t\t * @param {string|symbol} type The event type to invoke\n\t\t * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit<T = any>(type: EventType, evt: T) {\n\t\t\t((all.get(type) || []) as EventHandlerList).slice().map((handler) => { handler(evt); });\n\t\t\t((all.get('*') || []) as WildCardEventHandlerList).slice().map((handler) => { handler(type, evt); });\n\t\t}\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}